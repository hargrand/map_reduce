
/**
 * @file common.hpp
 * @brief Provides common testing utilities, assertion mechanisms,
 *        and helper functions for collection operations.
 */

#ifndef COMMON_HPP
#define COMMON_HPP

#include "../spt/assert.hpp"

#include <cstddef>
#include <functional>
#include <algorithm>
#include <iostream>
#include <string>

/**
 * @brief Tests the constructor of a collection.
 * @details This function creates a collection of a fixed size (10) using a generator
 *          function `fn`. It then verifies the values in the collection are as expected
 * @tparam T Type of elements in the collection
 * @tparam FN The type of the generator function.
 * @param fn A function that takes an index (std::size_t) and returns the expected element value.
 */
template <typename T, typename FN>
void test_constructor(FN fn)
{
    Collection<T> u(10, fn);
    auto vec = u.to_vector();

    for (std::size_t idx = 0; idx < u.size(); idx++)
        assert_equal(vec[idx], fn(idx),
                     "test_constructor: Failed to verify constructor");
}

/**
 * @brief Tests the constructor and `get` method of a collection.
 * @details This function creates a collection of a fixed size (10) using a generator
 *          function `fn`. It then iterates through the collection, verifying that
 *          each element retrieved via `get(idx)` matches the value generated by `fn(idx)`.
 * @tparam T Type of elements in the collection
 * @tparam FN The type of the generator and evaluator function.
 * @param fn A function that takes an index (std::size_t) and returns the expected element value.
 */
template <typename T, typename FN>
void test_access_get(FN fn)
{
    Collection<T> u(10, fn);

    for (std::size_t idx = 0; idx < u.size(); idx++)
        assert_equal(u.get(idx), fn(idx),
                     "test_constructor: Failed to verify constructor");
}

/**
 * @brief Tests the `set` method of a collection.
 * @details This function first creates a collection using a generator function `fn`.
 *          It then iterates through the collection, setting each element to a specified
 *          `value` and immediately verifying that the `get` method returns the same value.
 * @tparam COLL The type of the collection to be tested.
 * @tparam T The type of the value to set.
 * @tparam FN The type of the initial generator function.
 * @param value The value to set for each element in the collection.
 * @param fn A function to initialize the collection before testing the `set` operation.
 */
template <typename T, typename FN>
void test_access_set(T value, FN fn)
{
    Collection<T> u(10, fn);

    for (std::size_t idx = 0; idx < u.size(); idx++)
    {
        u.set(idx, value);
        assert_equal(u.get(idx), value,
                     "Failed to correctly set element in collection");
    }
}

/**
 * @brief Tests a binary collection operation (e.g., element-wise addition, subtraction).
 *        It applies a collection function `cfn` to two input collections `u` and `v`,
 *        and then verifies each element of the resulting collection `w` against
 *        the expected value calculated by a scalar function `fn` applied to corresponding
 *        elements of `u` and `v`.
 *
 * @tparam COLL The type of the collections (e.g., `std::vector<int>`).
 * @tparam COLL_FN The type of the collection function (e.g., `std::function<COLL(const COLL&, const COLL&)>`).
 * @tparam FN The type of the scalar function (e.g., `std::function<int(int, int)>`).
 * @param u The first input collection.
 * @param v The second input collection.
 * @param cfn The collection function to test, which takes two collections and returns a new collection.
 * @param fn The scalar function used to calculate the expected value for each element.
 */
template <typename COLL, typename COLL_FN, typename FN>
void test_operation(const COLL &u, const COLL &v, COLL_FN cfn, FN fn)
{
    COLL w = cfn(u, v);
    auto u_iter = u.cbegin();
    auto v_iter = v.cbegin();

    // Assert that the resulting collection has the same size as the input collections
    // This is a common assumption for element-wise operations.
    // If sizes can differ, this assertion might need to be adjusted or removed.
    assert_equal(w.size(), u.size(),
                 "Resulting collection size mismatch with u.");
    assert_equal(w.size(), v.size(),
                 "Resulting collection size mismatch with v.");

    // If collections are empty, the loop won't run, which is fine.
    // If they are non-empty, iterators will be valid.
    // The loop assumes u, v, and w have compatible iterators and sizes.
    // For robustness, consider adding checks for empty collections or size mismatches
    // before entering the loop, or ensure cfn handles them gracefully.
    for (auto w_iter = w.cbegin(); w_iter != w.cend(); ++w_iter, ++u_iter, ++v_iter)
    {
        auto actual = *w_iter;
        auto expected = fn(*u_iter, *v_iter);

        assert_equal(actual, expected,
                     "Operation failure: operands " + std::to_string(*u_iter) + " " + std::to_string(*v_iter) + "\n\t actual: " + std::to_string(actual) + "\n\t expected: " + std::to_string(expected));
    }
}

/**
 * @brief Tests a collection reduction operation (e.g., sum, product).
 *        It applies a collection function `cfn` to an input collection `u`
 *        and verifies the single resulting value against the expected value
 *        calculated by iteratively applying a scalar function `fn` to the elements of `u`.
 *
 * @tparam COLL The type of the collection (e.g., `std::vector<int>`).
 * @tparam COLL_FN The type of the collection function (e.g., `std::function<int(const COLL&)>`).
 * @tparam FN The type of the scalar function (e.g., `std::function<int(int, int)>`).
 * @param u The input collection.
 * @param cfn The collection function to test, which takes a collection and returns a single value.
 * @param fn The scalar function used to iteratively calculate the expected reduced value.
 */
template <typename COLL, typename COLL_FN, typename FN>
void test_reduce(const COLL &u, COLL_FN cfn, FN fn)
{
    auto actual = cfn(u);
    auto u_iter = u.cbegin();
    auto expected = *u_iter;

    // If the collection is empty, this logic might fail or produce undefined behavior
    // as it dereferences u_iter before checking for end.
    // Consider adding a check for u.empty() and handling it appropriately
    // (e.g., asserting or returning a default value if reduction of empty collection is defined).
    assert_true(u.size() > 0,
                "test_reduce called with an empty collection, which is not supported by this test's logic.");

    for (++u_iter; u_iter != u.cend(); ++u_iter)
        expected = fn(expected, *u_iter);

    assert_equal(actual, expected,
                 "Reduce failure:\n\t actual: " + std::to_string(actual) + "\n\t expected: " + std::to_string(expected));
}

/**
 * @brief Tests a dot product-like operation on two collections.
 *        It applies a collection function `fn` to two input collections `u` and `v`
 *        to get an actual result. It then calculates the expected result by first
 *        zipping `u` and `v` with `zip_fn` and then reducing the zipped result with `reduce_fn`.
 *
 * @tparam COLL The type of the collections (e.g., `std::vector<int>`).
 * @tparam COLL_FN The type of the collection function for the dot product (e.g., `std::function<int(const COLL&, const COLL&)>`).
 * @tparam ZIP_FN The type of the zip function (e.g., `std::function<COLL(const COLL&, const COLL&)>`).
 * @tparam RED_FN The type of the reduction function (e.g., `std::function<int(const COLL&)>`).
 * @param u The first input collection.
 * @param v The second input collection.
 * @param fn The collection function to test, which computes the dot product.
 * @param zip_fn The function to "zip" or combine elements from `u` and `v` into an intermediate collection.
 * @param reduce_fn The function to reduce the intermediate collection to a single value.
 */
template <typename COLL, typename COLL_FN, typename ZIP_FN, typename RED_FN>
void test_dot(const COLL &u, const COLL &v, COLL_FN fn, ZIP_FN zip_fn, RED_FN reduce_fn)
{
    auto actual = fn(u, v);
    auto expected = reduce_fn(zip_fn(u, v));

    assert_equal(actual, expected,
                 "Dot failure:\n\t actual: " + std::to_string(actual) + "\n\t expected: " + std::to_string(expected));
}

#endif // COMMON_HPP